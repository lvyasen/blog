---
title: Mysql 复制
urlname: dozzkrknz1tmqevl
date: '2022-12-26 09:59:52 +0800'
tags:
  - 复制
categories:
  - mysql
---

> 复制功能不仅有利于构建高性能的应用，同时也是高可用性、可扩展性、灾难恢复、备份、数据分析以及数据仓库等工作的基础。

## 概述

> 复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。
> 的实现机制可以这样概括，首先在源服务器（sourceserver）上，任何数据修改和数据结构变更的事件（event）都会被写入日志文件中，然后，副本服务器从源服务器上的日志文件中读取这些事件并在本地重放执行。
> 这是一个异步处理的过程，也就是说，并不能保证副本服务器上的数据是最新的。

### 用途

#### 数据分发

> MySQL 的复制通常不会对带宽造成很大的压力。

#### 读流量扩展

> 通过 MySQL 的复制可以将读操作分布到多台服务器上，实现对读密集型应用的优化，并且实现很方便，通过简单的代码修改就能实现基本的负载均衡。
> 对于小规模的应用，可以简单地对机器名做硬编码或使用 DNS 轮询（将一个机器名指向多个 IP 地址）。当然也可以使用更复杂的方法，例如网络负载均衡这一类的标准负载均衡解决方案，它们能够很好地将负载分配到不同的 MySQL 服务器上。

#### 备份

> 复制是一项有助于备份的有价值的技术，但副本不是备份，也不能够取代备份

#### 分析与报告

> 为报告/分析（在线分析处理，OLAP）查询使用专用的副本是一项很好的策略，可以很好地隔离此类查询产生的压力，以避免对满足外部客户需求的在线业务产生影响。复制可以很好地实现此类隔离。

#### 高可用性和故障切换

> 复制有助于避免 MySQL 成为应用程序中的单点故障，一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间。

#### MySQL 升级测试

> 这种做法比较普遍，先使用一个更高版本的 MySQL 作为副本，确保查询能够在此副本上按照预期执行，再升级所有的实例。

### 如何工作的？

> 在复制架构中，读取和重放日志事件是解耦的，这就允许读取日志和重放日志异步进行，也就是说，这里的 I/O 线程和 SQL 线程都是可以独立运行的

复制的步骤：

1. 源端把数据更改记录到二进制日志中，称之为“二进制日志事件”（binary log events）。
2. 副本将源上的日志复制到自己的中继日志中。
3. 副本读取中继日志中的事件，将其重放到副本数据之上。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25799318/1672020746176-d89756fa-e690-4a80-abb6-d0dac1997047.png#averageHue=%23f0f0f0&clientId=u8c200dee-6a7f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=244&id=u55c5cdd9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=762&originWidth=1440&originalType=binary∶=1&rotation=0&showTitle=false&size=168567&status=done&style=none&taskId=uf25dc3e1-0526-4784-a1b6-81b70f7b983&title=&width=462)

## 复制原理

### 复制的格式

> MySQL 提供了三种不同的二进制日志格式，通过 `binlog_format`设置给是。
>
> 1. 基于语句的。
> 2. 基于行的。
> 3. 混合模式。

#### 基于语句的复制

> 是通过记录所有在源端执行的数据变更语句来实现的。
> 当副本从中继日志读取到事件并执行时，实际上是重新执行在源端执行过的 SQL 语句。
> 这种格式的主要优点是简单且紧凑。一条更新了大量数据的 SQL 语句，在二进制日志中可能仅仅需要几十字节存储。
> 其最大的弊端则在于会遇到某些具有“不确定性”的 SQL 语句问题。

#### 基于行的复制

> 基于行的复制将事件写入二进制日志，该事件包含了该行记录发生了什么改变。
> 但是，因为这种模式的确定性，相比基于语句的方式来说，其实发生了很大的变化。
> 通过查看二进制日志中的事件，可以看到究竟是哪一行记录发生了什么样的改变。
> 在基于语句的复制模式下，SQL 语句在执行时被解析，服务器在执行时找到所有需要变更的记录进行操作。
> 而在基于行的复制模式下，每条被改变的记录都会作为事件被写入二进制日志，这可能会让二进制日志的大小发生巨大的增长。

#### 混合模式

> “混合模式”（the mixed method）试图结合以上两种格式的优点。
> 在这种模式下，事件的写入，默认使用基于语句的格式，仅在需要时才切换到基于行的格式。

### 全局事务标识

> 在 MySQL 5.6 之前，副本必须跟踪连接到源时读取的二进制日志文件和日志位置。
> 例如，一个副本连接到上游源并从文件 binlog.000002 的 2749 位置读取数据。
> 当副本从该二进制日志中读取事件时，它每次都会向后推进日志位点。
> 如果就在这时，故障发生了！比如源数据库崩溃了，必须从备份中重建数据。
> 那么问题来了：在源端，如果二进制日志位点重新开始，怎么能重新将副本连接到源库？确定从哪个位点开始连接是一个非常复杂的过程。
> 如果指向的位点太早，那么副本上就会获得重复的事件，如果指向的位点太晚，则会漏掉事件。无论使用哪种方式，都难以正确地将副本连接到源库。
> 为了解决这个问题，MySQL 新增了另一种跟踪复制位点的方法：全局事务标识符（GTID）。5.6 之后
> 使用 GTID，源服务器提交的每个事务都被分配一个唯一标识符。
> 此标识符是由 server_uuid 和一个递增的事务编号组成的。
> 当事务被写入二进制日志时，GTID 也随之被写入。回顾本章前面的内容可以了解到，副本将从源库读取的二进制日志事件先写入本地中继日志，再使用 SQL 线程执行该事务，将变更应用到本地副本上。
> 当 SQL 线程提交事务时，它也会将 GTID 标记为执行完成。
> GTID 解决了运行 MySQL 复制的一个令人痛苦的问题：处理日志文件和位置。

### 崩溃后的复制安全

> 虽然 GTID 解决了日志文件和位置问题，但还有一些其他问题困扰着 MySQL 的管理员。在本章后面，我们将讨论一些常见的故障场景；但是，在此之前，有一些设置可以极大地改善使用复制的体验。
> 为了尽量降低复制中断的可能性，建议 MySQL 的部分参数按照如下讲解内容进行配置。
>
> - innodb_flush_log_at_trx_commit=1
>   - 严格来说，这并不是一个复制相关的配置。不过，这个参数可以保障每个事务日志都被同步地写到磁盘。这是一个符合 ACID 要求的配置，将最大限度地保护你的数据——即使是在复制中也是这样。这是因为二进制日志事件首先被提交，然后事务将被提交并写入磁盘。将此参数设置为 1 将增加磁盘写入操作的频次，同时确保数据的持久性。
>   - 表示在每次事务提交的时候，都把 log buffer 刷到文件系统中(os buffer)去，并且调用文件系统的“flush”操作将缓存刷新到磁盘上去
> - sync_binlog=1
>   - 该变量控制 MySQL 将二进制日志数据同步到磁盘的频率。
>   - 将此值设置为 1 意味着在每次事务执行的时候都会把二进制日志同步写入磁盘。
>   - 这可以防止在服务器崩溃时丢失事务。就像之前的配置参数一样，它也会增加磁盘写入量。
> - relay_log_info_repository=TABLE
>   - 以前，MySQL 的复制通常依赖磁盘上的文件来跟踪复制位置。
>   - 这意味着，复制完成事务操作之后，还需要完成同步写入磁盘操作。
>   - 如果在事务提交和同步之间发生了服务器崩溃，此时，磁盘上的文件将可能包含错误的文件和位置信息。在该配置下，该信息将被转移到 MySQL 本身的 InnoDB 表中，允许复制更新同一事务中的事务和中继日志信息。
>   - 这会在一个原子操作中完成，并有助于崩溃恢复。
> - relay_log_recovery=ON
>   - 简单地说，该参数使得副本服务器在检测到崩溃时会丢弃所有本地中继日志，并从源服务器中获取丢失的数据。
>   - 这确保了在崩溃中发生的磁盘上的任何损坏或不完整的中继日志都是可恢复的。
>   - 配置该参数后，不再需要配置 sync_relay_log，因为在发生崩溃时，中继日志将被删除，也就无须花费额外的操作将它们同步到磁盘。

### 延迟复制

> 在某些场景下，在一个拓扑结构中，某些副本有一些延迟反而是有好处的。
> 在这个策略下，可以让副本中的数据保持在线并且持续运行，但同时落后于源数据库数小时或者数天。
> 延迟复制的配置语句是 CHANGE REPLICATION SOURCE TO，配置选项为 SOURCE_DELAY。

删除了一个表。从备份中恢复可能需要几个小时。如果使用了延迟复制的副本，则可以找到 DROP TABLE 语句对应的 GTID，使副本服务器的复制运行到表被删除之前的时间点，这会大大减少修复时间。

### 多线程复制

> 在复制技术中，历史非常悠久的挑战之一就是，虽然在源上数据可以并行写入，但在副本上只能是单线程的。最
> 新的 MySQL 版本则提供了多线程复制能力（参见图 9-2），可以在副本端运行多个 SQL 线程，从而加快本地中继日志的应用。
> 多线程复制有两种模式：
>
> - DATABASE。
>   - 在 DATABASE 模式下，可以使用多线程更新不同的数据库；但不会有两个线程同时更新同一个数据库。
>   - 如果将数据分布在 MySQL 的多个数据库中，则可以同时并且一致地更新它们，这种模式非常有效。
> - LOGICAL_CLOCK
>   - 允许对同一个数据库进行并行更新，只要它们都是同一个二进制日志组提交的一部分。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25799318/1672022155775-196380a3-6df4-4074-b08f-7db23e0da335.png#averageHue=%23eeeeee&clientId=u8c200dee-6a7f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=ub6755158&margin=%5Bobject%20Object%5D&name=image.png&originHeight=759&originWidth=1440&originalType=binary∶=1&rotation=0&showTitle=false&size=169459&status=done&style=none&taskId=u0c2f8538-a291-42ee-a063-7e3b6859540&title=&width=516)

#### 二进制组

> 为了更好地解释这一点，这里将使用 Morgan Tocker 的一个类比（参见链接 35）：一艘渡轮试图将乘客从 A 点运送到 B 点。
> 在 MySQL 5.0 中，渡轮将从 A 点接载一位乘客，然后将他转移到 B 点。A 和 B 之间的行程大约需要 10 分钟，在此期间可能会有几名新乘客到达 A 点并排队等待，这并不重要。当渡轮回到 A 点时，它只会搭载排队中的下一位乘客。
> 在 MySQL 5.6 中，渡轮将在 A 点接载所有排队等待的乘客，然后将他们转移到 B 点。每次返回 A 点接载新乘客时，它会继续接载所有排队等待的乘客并将他们转移到 B 点。
> 在实际的情况中，许多乘客都会在等待渡轮返回 A 的过程中到达 A，并且 A 和 B 之间的行程往往需要一些时间，这种方式性能明显会更好。当然，这在单线程运行的简单基准测试中，是无法测量的。
> MySQL 5.7 及更高版本的行为与 5.6 类似，因为它将从 A 点接载所有等候的乘客并将他们转移到 B 点，但新版本中有另一个显著的增强！
> 当渡轮返回 A 点以接载等候的乘客时，可以将其配置为等待更长的时间，因为知道可能会有新乘客到达。例如：如果你知道 A 点和 B 点之间的行程持续 10 分钟，为什么不在 A 点多等 30 秒再出发呢？这可以节省往返行程次数，并提高单次运输的乘客总数。
> 人工延迟的配置参数是 binlog_group_commit_sync_delay（以微秒为单位的延迟）和 binlog_group_commit_sync_no_delay_count（决定中止等待之前要等待的事务数）。
> 在这个例子中，乘客显然是事务，而轮渡是一个开销很大的 fsync()操作。需要注意的是，只有一艘渡轮在运行（一组有序的二进制日志），因此控制这些行为的一些参数，是一些高级的选项。

### 半同步复制

> 在启用半同步复制后，源在完成每个事务提交时，都需要确保事务至少被一个副本所接收。
> 需要确认副本已收到并成功将其写入自己的中继日志（但不一定应用到本地数据）。
> 一个值得注意的重要事情是，如果在一定时间范围内没有副本确认事务，MySQL 将恢复到标准的异步复制模式。这时事务并不会失败。这也说明，半同步复制不是一种防止数据丢失的方法，而是可以让你拥有更具弹性的故障切换的更大工具集的一部分。
