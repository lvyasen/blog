---
title: 设计模式 基础知识
urlname: kksxzv7xnmhf2gyo
date: '2022-12-26 14:32:03 +0800'
tags: []
categories: []
---

tags: [设计模式基础知识]
categories: [设计模式]
cover: ''

---

① 设计模式从何而来？
② 设计模式是什么？
③ 设计模式有什么用？

## 面向对象设计原则

① 单一职责原则（Single Responsibility Principle，SRP）。
② 开闭原则（Open-Closed Principle，OCP）。
③ 里氏代换原则（Liskov Substitution Principle，LSP）。
④ 依赖倒转原则（Dependency Inversion Principle，DIP）。
⑤ 接口隔离原则（Interface Segregation Principle，ISP）。
⑥ 合成复用原则（Composite Reuse Principle，CRP）。
⑦ 迪米特法则（Law of Demeter，LoD）。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/25799318/1672101759934-9f0bde91-4984-4b77-a735-fe6487375475.png#averageHue=%23efefef&clientId=u132ff679-6ccc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=315&id=u07f4329a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=629&originWidth=1440&originalType=binary∶=1&rotation=0&showTitle=false&size=321104&status=done&style=none&taskId=uc0b36119-06ed-4a31-bb02-f796891965e&title=&width=720)

### 单一职责原则

> 它用于控制类的粒度大小。
> **单一职责原则（Single Responsibility Principle，SRP）**：一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
> 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，这需要设计人员具有较强的分析设计能力和相关实践经验。

### 开闭原则

> 它是最重要的面向对象设计原则。
> **开闭原则（Open-Closed Principle，OCP）**：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
> 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。
> 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。

### 里氏替换原则

> **里氏代换原则（Liskov Substitution Principle，LSP）**：所有引用基类（父类）的地方必须能透明地使用其子类的对象
> 里氏代换原则是实现开闭原则的重要方式之一。
> 由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
> 在运用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。
> 程序运行时，子类实例替换父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。

### 依赖倒置原则

> 如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。
> **依赖倒转原则（Dependency Inversion Principle，DIP）**：抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
> 依赖倒转原则要求在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。
> 为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。
> 在引入抽象层后，系统将具有很好的灵活性。
> 在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中。这
> 样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，就能扩展系统的功能，满足开闭原则的要求。
>
> 在实现依赖倒转原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependency Injection，DI）
> 的方式注入其他对象中。
> 依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。
> 常用的注入方式有 3 种：
>
> - 构造注入：构造注入是指通过构造函数来传入具体类的对象。
> - 设值注入（Setter 注入）：通过 Setter 方法来传入具体类的对象。
> - 接口注入：通过实现在接口中声明的业务方法来传入具体类的对象
>
> 这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象

### 接口隔离原则

> **接口隔离原则（Interface Segregation Principle，ISP）**：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
> 根据接口隔离原则，当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。
> 每个接口应该承担一种相对独立的角色。
> 这里的“接口”有两种不同的含义：
>
> - 一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；
>   - 当把“接口”理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫作“角色隔离原则“
> - 某种语言具体的“接口”定义，有严格的定义和结构，例如 Java 语言中的 interface。对于这两种不同的含义，ISP 的表达方式以及含义都有所不同。
>   - 如果把“接口”理解成狭义的特定语言的接口，那么 ISP 表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便。为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并各承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。

### 合成复用原则

> **合成复用原则（Composite Reuse Principle，CRP）**：尽量使用对象组合，而不是继承来达到复用的目的。
>
> 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。
> 简言之：复用时要尽量使用组合／聚合关系（关联关系），少用继承。
>
> 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，
>
> - 通过组合／聚合关系：“Has-A”的关系。
> - 通过继承：“Is-A”关系。
>
> “Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的“一种”；
> 而“Has-A”则不同，它表示某一个角色具有某一项责任。
> 但首先应该考虑使用组合／聚合，组合／聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。
> 其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。
> 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用。
> 如果基类发生改变，那么子类的实现也不得不发生改变。
> 从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。
> 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用。
> 相对继承关系而言，“黑箱”复用的耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作。合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。

### 迪米特法则

> **迪米特法则（Law of Demeter，LoD）**：一个软件实体应当尽可能少地与其他实体发生相互作用。
> 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易。这是对软件实体之间通信的限制。
> 迪米特法则要求限制软件实体之间通信的宽度和深度。
> 迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。
> 迪米特法则还有几种定义形式：不要和“陌生人”说话，只与你的直接朋友通信等。在迪米特法则中，对于一个对象，其“朋友”包括以下几类：
> （1）当前对象本身（this）。
> （2）以参数形式传入到当前对象方法中的对象。
> （3）当前对象的成员对象。
> （4）如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。
> （5）当前对象所创建的对象。
> 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。
> 迪米特法则要求在设计系统时，应该尽量减少对象之间的交互。
> 如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用；如果其中一个对象需要调用另一个对象的方法，可以通过第三者转发这个调用。
> 简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。

## 设计模式从何而来？

> 与很多软件工程技术一样，模式起源于建筑领域，与只有几十年历史的软件工程相比，已经拥有几千年沉淀的建筑工程有太多值得学习和借鉴的地方。
> 模式是如何诞生的？先来认识一个人——Christopher Alexander（克里斯托弗·亚历山大），哈佛大学建筑学博士、美国加州大学伯克利分校建筑学教授、加州大学伯克利分校环境结构研究所所长、美国艺术和科学院院士等，他还有一个“昵称”——模式之父（the father of patterns）。Christopher Alexander 博士及其研究团队用了约 20 年的时间，对住宅和周边环境进行了大量的调查研究和资料收集工作，发现人们对舒适住宅和城市环境存在一些共同的认知规律。Christopher Alexander 在著作 A PatternLanguage：Towns，Buildings，Construction 中把这些认同规律归纳为 253 个模式（Pattern），对每一个模式都从前提条件（Context）、目标问题（Theme 或 Problem）、解决方案（Solution）
> 三方面进行了描述，并给出了从用户需求分析到建筑环境结构设计直至经典实例的过程模型。
> 在 Christopher Alexander 的另一部经典著作 The Timeless Way of Building（《建筑的永恒之道》）中，
> 他给出了关于模式的定义：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。这个定义可以简单地用一句话表示：
> 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。

## 设计模式是什么?

> 设计模式（Design Pattern）**:是一套被反复使用的、多数人知晓的、经过分类编目的代码设计经验的总结，使用设计模式是为了可以重用代码，让代码更容易被他人理解并且提高代码的可靠性**。

设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。

- **模式名称**（Pattern Name）通过一两个词来为模式命名，以便我们更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF 设计模式中没有一个模式用人名命名）；
- **问题**（Problem）描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；
- **解决方案**（Solution）描述了一个设计模式的组成部分，以及这些组成部分之间的相互关系、各自的职责和协作方式，通常解决方案通过 UML 类图和核心代码进行描述；
- **效果**（Consequence）描述了模式的优缺点以及在使用模式时应权衡的问题。

根据它们的用途，设计模式可分为

- 创建型（Creational）
- 结构型（Structural）
- 行为型（Behavioral）

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25799318/1672036844354-7a002096-feb4-4839-9830-28743bb64dc3.png#averageHue=%23f4f4f4&clientId=u68994805-0490-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1040&id=uabe4eb65&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2080&originWidth=1440&originalType=binary∶=1&rotation=0&showTitle=false&size=635153&status=done&style=none&taskId=u8a6c40c9-3dad-4802-9583-3fd900864ae&title=&width=720)

## 设计模式有什么用?

> 简单来说，设计模式至少有如下几个用途：
>
> - 设计模式来源于众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案可以避免做一些重复性的工作，有助于提高设计和开发效率。
> - 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为开发人员节省不少时间。无论使用哪种编程语言，做什么类型的项目，甚至一个国际化的开发团队，当面对同一个设计模式时，大家的理解并无歧义，因为设计模式是跨语言、跨平台、跨应用、跨国界的。
> - 大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得开发人员可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免经常做一些重复的设计、编写一些重复的代码。此外，随着软件规模的日益增大，软件寿命的日益变长，系统的可维护性和可扩展性也越来越重要，许多设计模式将有助于提高系统的灵活性和可扩展性，在不修改或者少修改现有系统的基础上增加、删除或者替换功能模块，如果一点设计模式都不懂，要做到这一点还是很困难的。
> - 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。对于离职人员的项目，只要接手人员也懂设计模式，就能够很快理解该项目的设计思路和实现方案，使得后续工作顺利进行。
> - 最后一点对初学者很重要，学习设计模式将有助于初学者更加深入地理解面向对象思想。例如，如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如何不修改源代码增加新功能？同时还能够更好地阅读和理解现有类库（如 JDK）与其他系统中的源代码，早点脱离面向对象编程的“菜鸟期”。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25799318/1672103973137-6338a759-2b7f-4779-bfed-592d7e74117e.png#averageHue=%23f1f1f1&clientId=u125ecfbf-0e2b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=771&id=ua5d756db&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1541&originWidth=1440&originalType=binary∶=1&rotation=0&showTitle=false&size=690514&status=done&style=none&taskId=uce202ea3-af07-4009-989a-e063937992c&title=&width=720)

## PHP 设计模式例子

> [DesignPatternsPHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP) > [中文文档](https://designpatternsphp.readthedocs.io/zh_CN/latest/README.html)
