---
title: MySQL 架构
urlname: vyh7nztf85gsqssc
date: '2022-11-22 08:37:09 +0800'
tags:
  - mysql
categories:
  - mysql
---

- mysql 是如何设计的？为什么这么设计？
- mysql 用的什么数据结构？为什么要用这种数据结构？
- mysql 是如何解决并发的？
- mysql 是如何保证数据已执行的？
- mysql 的存储引擎都有哪些？区别是什么？
  > MySQL 是一个单进程多线程架构的数据库管理系统

## Mysql 的设计架构

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25799318/1669077910969-9eee48c2-0a5b-4996-b7d3-4f499d16fbe5.png#averageHue=%23f9f9f9&clientId=u3d1ce0d7-6da4-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub84c660e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=729&originWidth=1440&originalType=url∶=1&rotation=0&showTitle=false&size=149155&status=done&style=none&taskId=uab7c9dde-f818-4929-b530-5463bc813c3&title=)

1. 第一层处理连接，身份确认、确保安全性，基本上数据库都会有这层。
2. mysql 核心功能在这层实现，查询分析、分析、优化、所有内置函数、存储过程、触发器、视图。
3. 存储引擎层，负责数据库的存储和提取，

### 连接管理与安全性

> 每个客户端连接都会在服务器中拥有一个线程，该连接的查询只会在这个单独的线程中执行，
> 该线程驻留在一个内核和一个 CPU 上。
> 服务器维护了一个缓冲区，用于存放已就绪的线程，因此不需要为每个新的连接创或销毁线程。

### 优化与执行

> mysql 解析查询会创建内部数据结构（解析树），然后对其进行各种优化
> 如：重写查询、决定表的读取顺序、选取合适的索引。
> 用户可以使用关键字先优化器传递提示，从而影响优化器的决策过程。
> 优化器并不关心是什么存储引擎。
> 从 5.7 版本后查询缓存被弃用。

### 并发控制

> 一般分为两中级别的并发控制：服务器级别、存储引擎级别。

#### 读写锁

> 处理并发读/写系统通常实现了一个由两种锁组成的系统。
> 资源上读锁是共享的，或者说相互不阻塞，多个客户端可以同时读取同一个资源而互不影响。
> 写锁是排他的，一个写锁会阻塞其他读锁或者写锁，这样能确保同一个时间点只有一个客户端能执行写入，并防止其他客户端读取正在写入的资源。

- 共享锁（share lock）也叫读锁。
- 排他锁（ exclusive ）也叫写锁。

#### 锁粒度

> 尽量只锁定包含需要修改的部分，而不是所有数据。
> 但是加锁也需要消耗资源，如 获取锁、检查锁是否空闲、锁释放，都会增加系统开销。
> 如果系统花费大量时间来管理锁而不是存取数据，那么系统性能就会收到影响。
> 锁是数据库实现一致性的保证方法。

表锁：

> 表锁（table lock）是 mysql 中开销最小的锁策略。
> 他会锁定整张表，当客户端想对表数据进行写操作（插入、删除、修改），需要先获得一个锁，这会阻塞其他客户端对该表的所有读写操作。
> 只有没人进行写操作时，其他读取的客户端才能获得读锁，读锁之间不会相互阻塞。

行级锁：

> 行级锁（row lock）可以最大程度上支持并发，但是也带来了最大的锁开销。

### 事务

#### 隔离级别

1. read uncommited（读未提交）：在事务中可以看到其他事务还没有提交的数据。
2. read commited（读已提交）：一个事务可以看到其他事务在他开始之后提交的修改，但是在该事务提交前，其他事务看不到该事务的修改。该级别允许不可重复读（norepeatread），这意味着同一个事务，执行两次相同语句，但是结果可能不同。
3. repeatable read（可重复读）：一个事务中多次读取相同的数据行数结果是一致的。但是不能解决幻读（phantom read），幻读：指某个事务在读取某个范围的记录时，另一个事务向该范围插入了数据，当事务再次读取该范围时，会出现幻行。
4. serializeable（可的串行化）：该级别通过强制事务按照次序执行，使不同事务不可能产生冲突。

#### 死锁

> 两个或多个事务相互持有和请求相同资源的锁，产生了循环依赖。

如何解决：

1. 死锁检测和锁超时机制：innodb 引擎，检测到循环依赖时立即返回错误信息。
2. 当超过锁等待超时时间后直接终止查询。这样做不是特别好，innodb 的做法是将持有最少行级排他锁的事务回滚。

#### 事务日志

> 事务日志有助于提高事务效率。
> 存储引擎只需要更改内存中的数据副本，而不是每次都修改磁盘中的表，这样非常快。
> 事务日志采用追加写操作，是在硬盘中一小块区域内顺序 I/O。
> 如果修改操作写入了事务日志，即使系统崩溃也能恢复。

#### 复制

> 将一个节点的写操作分发到其他节点，称之为复制。

#### 数据文件结构

> 在 8.0 后，mysql 将表表的元数据（metadata）重写设计为数据字典，包含在 .idb 文件中。
> 这样修改后，我们不仅仅依赖 information_schema 来检索表定义和元数据，而是引入了字典缓存，
> 字典缓存：基于最近最少使用（LRU）的内存缓存，包括 区定义、表定义、存储过程定义。
> 好处：减少了磁盘 IO、非常高效、

####

### Innodb

> innodb 是 mysql 默认的存储引擎，默认情况下 innodb 将数据存储在一系列的数据文件中，这些文件系统被称为表空间（tablespace）。
> innodb 通过 MVCC（multi-version concurrency control） 实现高并发。
> 默认 repeatable read（可重复读）隔离级别，并通过 间隙锁（next-key lock）防止在这个级别上的幻读，innodb 不仅锁定在查询中涉及的行，还会对索引结构中的间隙进行锁定，防止幻行被插入。
> 基于聚簇索引构建，聚簇索引提供了非常快速的主键查询。

做的优化：

- 从磁盘预取数据的可预测性预读
- 自由的在内存中构建哈希索引
- 插入缓冲区（insert buffer）：能加速插入操作。

#### JSON 文档支持

> 5.7 被引入。
> 实现了 JSON 文档的自动验证（无效的文档会产生错误），优化了存储可以快速读取。
