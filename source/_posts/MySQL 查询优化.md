---
title: MySQL 查询优化
urlname: mf1usp3wqy7563k9
date: '2022-12-16 14:53:05 +0800'
tags:
  - mysql
categories:
  - mysql
---

> 如果把查询看作一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。
> 从客户端到服务器，然后在服务器上进行语法解析，生成执行计划，执行，并给客户端返回结果。
> “执行”可以被认为是整个生命周期中最重要的阶段，这其中包括大量为了检索数据对存储引擎的调用以及调用后的数据处理，包括排序、分组等。
> 在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络、CPU 计算、生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU 操作和内存不足时导致的 I/O 操作上消耗时

## 优化数据访问

> 简单来说就是减少访问的数据！

- 确认应用程序是否存在检索大量不必要的数据。一般就是减少访问的行和列。
- 确认 Mysql 服务层是否存在分析大量不需要的数据行。

**解决办法：**

- **解决太多的行：加上 limit 语句。**
- **解决太多的列：select 选择需要的列，不要使用 select \***
- **避免执行相同的查询，如用户信息可以存储在客户端不用每次到数据库中查询。**

## 重构查询方式

### 一个复杂查询还是多个简单查询

> 设计查询的时候，一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。

### 切分查询

> 有时候对于一个大查询，我们需要“分而治之”，将大查询切分成小查询，每个查询的功能完全一样，只完成一小部分，每次只返回一小部分查询结果。
> 删除旧数据就是很好的例子，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

### 分解联接查询

> 以对每一个表进行一次单表查询，然后将结果在应用程序中进行联接。

```sql
SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql'


# 使用下面的来代替
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id in (123,456,567,9098,8904);
```

分解联接的优势：
● 让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。例如，上面查询中的 tag mysql 已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了 ID 为 123、567、9098 的内容，那么第三个查询的 IN()中就可以少几个 ID。
● 将查询分解后，执行单个查询可以减少锁的竞争。
● 在应用层做联接，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
● 查询本身的效率也可能会有所提升。在这个例子中，使用 IN()代替联接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的联接要更高效。
● 可以减少对冗余记录的访问。在应用层做联接查询，意味着对于某条记录应用只需要查询一次，而在数据库中做联接查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。

## 查询的原理

### 查询的流程

1. 客户端给服务器发送一条 SQL 查询语句。
2. 服务器端进行 SQL 语句解析、预处理，再由优化器生成对应的执行计划。
3. MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。
4. 将结果返回给客户端。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25799318/1672017468502-dd91aa09-b9f6-473b-8156-599192a23190.png#averageHue=%23efefef&clientId=u15a4f108-4a10-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=u7f9ee4cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1331&originWidth=1440&originalType=binary∶=1&rotation=0&showTitle=false&size=234451&status=done&style=none&taskId=ub27b01ec-3ee0-43fe-b358-fc3ab208c96&title=&width=432)

### 通讯协议

> MySQL 的客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，我们无法也无须将一个消息切成小块来独立发送。
> 这种协议让 MySQL 通信变得简单快速，但是也从很多地方限制了 MySQL。
> 一个明显的限制是，这意味着没法进行流量控制。
> 一旦一端开始发送消息，另一端要接收完整个消息才能响应它。
> 当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是 MySQL 在向客户端推送数据的过程。

```php
<?php
$link
 = mysql_connect('localhost', 'user', 'p4ssword');
$result = mysql_query('SELECT * FROM HUGE_TABLE', $link);
while ($row = mysql_fetch_array($result) ) {
  // Do something with result
}
//这段代码看起来像是只有当你需要的时候，才通过循环从服务器端取出数据。
//而实际上，在上面的代码中，在调用mysql_query()的时候，PHP就已经将整个结果集缓存到内存中了。
//while循环只是从这个缓存中逐行取出数据。
```

### 查询状态

> 对于一个 MySQL 连接，或者一个线程，任何时刻都有一个状态，该状态表示了 MySQL 当前正在做什么。
> 最简单的就是使用 `show processlist`查看状态。
